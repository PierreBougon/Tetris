src/main/tetris.c:  return (tab->tabkey[i](data, &data->tetri_ig));
src/main/tetris.c:      aff_piece(&data->tetri_ig);
src/main/tetris.c:      if (get_key(data, key, data->keys, &data->tabkey) == 1)
src/piece/new_tetri.c:  tetri->width = tmp->data->width;
src/piece/new_tetri.c:  tetri->height = tmp->data->height;
src/piece/new_tetri.c:  tetri->color = tmp->data->color;
src/piece/new_tetri.c:  tetri->pos_x = rand() % (data->gamevar.win_width - tetri->width);
src/piece/new_tetri.c:  tetri->item = strcopy2d(tetri->item, tmp->data->item, tmp->data);
src/piece/new_tetri.c:      chose_tetri(data, tetri, &data->tetriminos);
src/piece/new_tetri.c:      create_cdlist(&data->tetri_ig, tetri);
src/piece/new_tetri.c:      chose_tetri(data, tetri, &data->tetriminos);
src/piece/new_tetri.c:      add_last_cdl(&data->tetri_ig, tetri);
src/piece/new_tetri.c:      chose_tetri(data, tetri, &data->tetriminos);
src/piece/new_tetri.c:      data->tetri_ig.root->data = tetri;
src/piece/new_tetri.c:      data->tetri_ig.root = data->tetri_ig.root->next;
src/piece/move.c:  itemdata = data->tetri_ig.root->data;
src/piece/move.c:  if ((int)to_move > data->gamevar.speed
src/piece/move.c:      && (itemdata->pos_y + itemdata->height + POS_GAME_Y
src/piece/move.c:	  < POS_GAME_Y + data->gamevar.win_height))
src/piece/move.c:      data->tetri_ig.root->data->pos_y += 1;
src/piece/move.c:  if (itemdata->pos_y + itemdata->height + POS_GAME_Y + 3
src/piece/move.c:      < POS_GAME_Y + data->gamevar.win_height)
src/piece/move.c:    tetri_ig->root->data->pos_y += 4;
src/piece/move.c:  if (itemdata->pos_x + POS_GAME_X
src/piece/move.c:    tetri_ig->root->data->pos_x -= 1;
src/piece/move.c:  if (itemdata->pos_x + itemdata->width + POS_GAME_X
src/piece/move.c:      < POS_GAME_X + data->gamevar.win_width)
src/piece/move.c:    tetri_ig->root->data->pos_x += 1;
src/piece/stop_piece.c:  itemdata = data->tetri_ig.root->data;
src/piece/stop_piece.c:  j = itemdata->pos_y - 1;
src/piece/stop_piece.c:  while (++j < itemdata->pos_y + itemdata->height)
src/piece/stop_piece.c:      i = itemdata->pos_x - 1;
src/piece/stop_piece.c:      while (++i < itemdata->pos_x + itemdata->width)
src/piece/stop_piece.c:	  if (itemdata->item[p][n] != ' ' && itemdata->item[p][n] != 0)
src/piece/stop_piece.c:	    data->tab_game[j + 1][i + 1] = itemdata->item[p][n];
src/piece/stop_piece.c:  itemdata = data->tetri_ig.root->data;
src/piece/stop_piece.c:  if (itemdata->pos_y + itemdata->height + POS_GAME_Y
src/piece/stop_piece.c:      == POS_GAME_Y + data->gamevar.win_height && refind == 0)
src/print/print_debug.c:  printf("DANS LE PRINT L1 DE ITEM = %s\n", tetriminos->root->data->item[1]);
src/print/print.c:  data->sub_win = subwin(data->win, 20, 12, 1, POS_GAME_X);
src/print/print.c:  wborder(data->sub_win, '|', '|', '-', '-', '/', '\\', '\\', '/');
src/print/print.c:  wrefresh(data->sub_win);
src/print/print.c:  data->score.act_time = time(NULL) - data->score.init_time;
src/print/print.c:  print_score(&data->score);
src/init/init.c:  data->sub_next = subwin(data->win, line, col, 1, POS_GAME_X + 15);
src/init/init.c:  wborder(data->sub_next, '|', '|', '-', '-', '/', '\\', '\\', '/');
src/init/init.c:  mvwprintw(data->sub_next, 0, 1, "Next");
src/init/init.c:  wrefresh(data->sub_next);
